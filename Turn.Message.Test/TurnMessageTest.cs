// 
//  Author:
//       Vitali Fomine <support@officesip.com>
// 
//  Copyright (c) 2010 OfficeSIP Communications
// 
//  This program is free software; you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation; either version 2 of the License, or
//  (at your option) any later version.
// 
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
//  GNU General Public License for more details.
//  
//  You should have received a copy of the GNU General Public License
//  along with this program; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
// 
using System;
using Turn.Message;
using NUnit.Framework;

namespace TestTurnMessage
{
	[TestFixture()]
	public class TurnMessageTest
	{
		/// <summary>
		/// http://tools.ietf.org/html/draft-ietf-behave-stun-test-vectors-04 - 2.1.Sample request
		///</summary>
		[Test()]
		public void ParseTest1()
		{
			byte[] bytes = new byte[]
			{
				0x00, 0x01, 0x00, 0x58, //     Request type and message length
				0x21, 0x12, 0xa4, 0x42, //     Magic cookie
				0xb7, 0xe7, 0xa7, 0x01, //  }
				0xbc, 0x34, 0xd6, 0x86, //  }  Transaction ID
				0xfa, 0x87, 0xdf, 0xae, //  }
				0x80, 0x22, 0x00, 0x10, //     SOFTWARE attribute header
				0x53, 0x54, 0x55, 0x4e, //  }
				0x20, 0x74, 0x65, 0x73, //  }  User-agent...
				0x74, 0x20, 0x63, 0x6c, //  }  ...name
				0x69, 0x65, 0x6e, 0x74, //  }
				0x00, 0x24, 0x00, 0x04, //     PRIORITY attribute header
				0x6e, 0x00, 0x01, 0xff, //     ICE priority value
				0x80, 0x29, 0x00, 0x08, //     ICE-CONTROLLED attribute header
				0x93, 0x2f, 0xf9, 0xb1, //  }  Pseudo-random tie breaker...
				0x51, 0x26, 0x3b, 0x36, //  }   ...for ICE control
				0x00, 0x06, 0x00, 0x09, //     USERNAME attribute header
				0x65, 0x76, 0x74, 0x6a, //  }
				0x3a, 0x68, 0x36, 0x76, //  }  Username (9 bytes) and padding (3 bytes)
				0x59, 0x20, 0x20, 0x20, //  }
				0x00, 0x08, 0x00, 0x14, //     MESSAGE-INTEGRITY attribute header
				0x9a, 0xea, 0xa7, 0x0c, //  }
				0xbf, 0xd8, 0xcb, 0x56, //  }
				0x78, 0x1e, 0xf2, 0xb5, //  }  HMAC-SHA1 fingerprint
				0xb2, 0xd3, 0xf2, 0x49, //  }
				0xc1, 0xb5, 0x71, 0xa2, //  }
				0x80, 0x28, 0x00, 0x04, //     FINGERPRINT attribute header
				0xe5, 0x7a, 0x3b, 0xcf, //     CRC32 fingerprint
			};

			TurnMessage message = TurnMessage.Parse(bytes, TurnMessageRfc.Rfc5389);

			Assert.AreEqual(@"evtj:h6vY", message.Username.Value);
			Assert.AreEqual(@"STUN test client", message.Software.Value);

			byte[] messageIntegrity = message.ComputeMessageIntegrity(@"VOkJxbRl1RmTxUk/WvJxBt", false);

			Helpers.AreArrayEqual(messageIntegrity, message.MessageIntegrity.Value);
			Assert.AreEqual(0x58, bytes[3]);

			uint fingerprint = message.ComputeFingerprint();

			Assert.AreEqual(fingerprint, message.Fingerprint.Value);
		}

		/// <summary>
		/// http://tools.ietf.org/html/draft-ietf-behave-stun-test-vectors-04 - 2.2.Sample IPv4 response
		///</summary>
		[Test()]
		public void ParseTest2()
		{
			byte[] bytes = new byte[]
			{
				0x01, 0x01, 0x00, 0x3c, //     Response type and message length
				0x21, 0x12, 0xa4, 0x42, //     Magic cookie
				0xb7, 0xe7, 0xa7, 0x01, //  }
				0xbc, 0x34, 0xd6, 0x86, //  }  Transaction ID
				0xfa, 0x87, 0xdf, 0xae, //  }
				0x80, 0x22, 0x00, 0x0b, //     SOFTWARE attribute header
				0x74, 0x65, 0x73, 0x74, //  }
				0x20, 0x76, 0x65, 0x63, //  }  UTF-8 server name
				0x74, 0x6f, 0x72, 0x20, //  }
				0x00, 0x20, 0x00, 0x08, //     XOR-MAPPED-ADDRESS attribute header
				0x00, 0x01, 0xa1, 0x47, //     Address family (IPv4) and xor'd mapped port number
				0xe1, 0x12, 0xa6, 0x43, //     Xor'd mapped IPv4 address
				0x00, 0x08, 0x00, 0x14, //     MESSAGE-INTEGRITY attribute header
				0x2b, 0x91, 0xf5, 0x99, //  }
				0xfd, 0x9e, 0x90, 0xc3, //  }
				0x8c, 0x74, 0x89, 0xf9, //  }  HMAC-SHA1 fingerprint
				0x2a, 0xf9, 0xba, 0x53, //  }
				0xf0, 0x6b, 0xe7, 0xd7, //  }
				0x80, 0x28, 0x00, 0x04, //     FINGERPRINT attribute header
				0xc0, 0x7d, 0x4c, 0x96, //     CRC32 fingerprint
			};

			string password = @"VOkJxbRl1RmTxUk/WvJxBt";

			TurnMessage message = TurnMessage.Parse(bytes, TurnMessageRfc.Rfc5389);

			Assert.AreEqual(@"test vector", message.Software.Value);
			Assert.AreEqual(@"192.0.2.1", message.XorMappedAddress.IpAddress.ToString());
			Assert.AreEqual(32853, message.XorMappedAddress.Port); 

			byte[] messageIntegrity = message.ComputeMessageIntegrity(password, false);

			Helpers.AreArrayEqual(messageIntegrity, message.MessageIntegrity.Value);
			Assert.AreEqual(0x3c, bytes[3]);

			uint fingerprint = message.ComputeFingerprint();
			Assert.AreEqual(fingerprint, message.Fingerprint.Value);

			byte[] actual = message.GetBytes(password, false, 0x20);
			Helpers.AreArrayEqual(bytes, actual);

			TurnMessage message2 = new TurnMessage()
			{
				MessageType = MessageType.BindingResponse,
				TransactionId = message.TransactionId,
				Software = message.Software,
				XorMappedAddress = message.XorMappedAddress,
				MessageIntegrity = new MessageIntegrity(),
				Fingerprint = new Fingerprint(),
			};

			byte[] actual2 = message2.GetBytes(password, false, 0x20);

			Helpers.AreArrayEqual(bytes, actual2);
		}

		/// <summary>
		/// http://tools.ietf.org/html/draft-ietf-behave-stun-test-vectors-04 - 2.3.Sample IPv6 response
		///</summary>
		[Test()]
		public void ParseTest3()
		{
			byte[] bytes = new byte[]
			{
				0x01, 0x01, 0x00, 0x48, //     Response type and message length
				0x21, 0x12, 0xa4, 0x42, //     Magic cookie
				0xb7, 0xe7, 0xa7, 0x01, //  }
				0xbc, 0x34, 0xd6, 0x86, //  }  Transaction ID
				0xfa, 0x87, 0xdf, 0xae, //  }
				0x80, 0x22, 0x00, 0x0b, //     SOFTWARE attribute header
				0x74, 0x65, 0x73, 0x74, //  }
				0x20, 0x76, 0x65, 0x63, //  }  UTF-8 server name
				0x74, 0x6f, 0x72, 0x20, //  }
				0x00, 0x20, 0x00, 0x14, //     XOR-MAPPED-ADDRESS attribute header
				0x00, 0x02, 0xa1, 0x47, //     Address family (IPv6) and xor'd mapped port number
				0x01, 0x13, 0xa9, 0xfa, //  }
				0xa5, 0xd3, 0xf1, 0x79, //  }  Xor'd mapped IPv6 address
				0xbc, 0x25, 0xf4, 0xb5, //  }
				0xbe, 0xd2, 0xb9, 0xd9, //  }
				0x00, 0x08, 0x00, 0x14, //     MESSAGE-INTEGRITY attribute header
				0xa3, 0x82, 0x95, 0x4e, //  }
				0x4b, 0xe6, 0x7b, 0xf1, //  }
				0x17, 0x84, 0xc9, 0x7c, //  }  HMAC-SHA1 fingerprint
				0x82, 0x92, 0xc2, 0x75, //  }
				0xbf, 0xe3, 0xed, 0x41, //  }
				0x80, 0x28, 0x00, 0x04, //     FINGERPRINT attribute header
				0xc8, 0xfb, 0x0b, 0x4c, //     CRC32 fingerprint
			};

			string password = @"VOkJxbRl1RmTxUk/WvJxBt";

			TurnMessage message = TurnMessage.Parse(bytes, TurnMessageRfc.Rfc5389);

			Assert.AreEqual(@"test vector", message.Software.Value);
			Assert.AreEqual(@"2001:db8:1234:5678:11:2233:4455:6677", message.XorMappedAddress.IpAddress.ToString());
			Assert.AreEqual(32853, message.XorMappedAddress.Port);

			byte[] messageIntegrity = message.ComputeMessageIntegrity(password, false);

			Helpers.AreArrayEqual(messageIntegrity, message.MessageIntegrity.Value);
			Assert.AreEqual(0x48, bytes[3]);

			uint fingerprint = message.ComputeFingerprint();
			Assert.AreEqual(fingerprint, message.Fingerprint.Value);

			byte[] actual = message.GetBytes(password, false, 0x20);
			Helpers.AreArrayEqual(bytes, actual);

			TurnMessage message2 = new TurnMessage()
			{
				MessageType = MessageType.BindingResponse,
				TransactionId = message.TransactionId,
				Software = message.Software,
				XorMappedAddress = message.XorMappedAddress,
				MessageIntegrity = new MessageIntegrity(),
				Fingerprint = new Fingerprint(),
			};

			byte[] actual2 = message2.GetBytes(password, false, 0x20);

			Helpers.AreArrayEqual(bytes, actual2);
		}

		/// <summary>
		/// http://tools.ietf.org/html/draft-ietf-behave-stun-test-vectors-04 - 2.4.Sample request with long-term authentication
		///</summary>
		[Test()]
		public void ParseTest4()
		{
			byte[] bytes = new byte[]
			{
				0x00, 0x01, 0x00, 0x60, //     Request type and message length
				0x21, 0x12, 0xa4, 0x42, //     Magic cookie
				0x78, 0xad, 0x34, 0x33, //  }
				0xc6, 0xad, 0x72, 0xc0, //  }  Transaction ID
				0x29, 0xda, 0x41, 0x2e, //  }
				0x00, 0x06, 0x00, 0x12, //     USERNAME attribute header
				0xe3, 0x83, 0x9e, 0xe3, //  }
				0x83, 0x88, 0xe3, 0x83, //  }
				0xaa, 0xe3, 0x83, 0x83, //  }  Username value (18 bytes) and padding (2 bytes)
				0xe3, 0x82, 0xaf, 0xe3, //  }
				0x82, 0xb9, 0x00, 0x00, //  }
				0x00, 0x15, 0x00, 0x1c, //     NONCE attribute header
				0x66, 0x2f, 0x2f, 0x34, //  }
				0x39, 0x39, 0x6b, 0x39, //  }
				0x35, 0x34, 0x64, 0x36, //  }
				0x4f, 0x4c, 0x33, 0x34, //  }  Nonce value
				0x6f, 0x4c, 0x39, 0x46, //  }
				0x53, 0x54, 0x76, 0x79, //  }
				0x36, 0x34, 0x73, 0x41, //  }
				0x00, 0x14, 0x00, 0x0b, //     REALM attribute header
				0x65, 0x78, 0x61, 0x6d, //  }
				0x70, 0x6c, 0x65, 0x2e, //  }  Realm value (11 bytes) and padding (1 byte)
				0x6f, 0x72, 0x67, 0x00, //  }
				0x00, 0x08, 0x00, 0x14, //     MESSAGE-INTEGRITY attribute header
				0xf6, 0x70, 0x24, 0x65, //  }
				0x6d, 0xd6, 0x4a, 0x3e, //  }
				0x02, 0xb8, 0xe0, 0x71, //  }  HMAC-SHA1 fingerprint
				0x2e, 0x85, 0xc9, 0xa2, //  }
				0x8c, 0xa8, 0x96, 0x66, //  }
			};

			string password = "The\u00ADM\u00AAtr\u2168";
			string username = "\u30DE\u30C8\u30EA\u30C3\u30AF\u30B9";
			string nonce = "f//499k954d6OL34oL9FSTvy64sA";
			string realm = "example.org";

			TurnMessage message = TurnMessage.Parse(bytes, TurnMessageRfc.Rfc5389);

			Assert.AreEqual(username, message.Username.Value);
			Assert.AreEqual(nonce, message.Nonce.Value);
			Assert.AreEqual(realm, message.Realm.Value);

			byte[] messageIntegrity = message.ComputeMessageIntegrity(password, true);

			Helpers.AreArrayEqual(messageIntegrity, message.MessageIntegrity.Value);
			Assert.IsTrue(message.IsMessageIntegrityValid(password, true));

			byte[] actual = message.GetBytes(password, true);
			Helpers.AreArrayEqual(bytes, actual);

			TurnMessage message2 = new TurnMessage()
			{
				MessageType = MessageType.BindingRequest,
				TransactionId = message.TransactionId,
				Username = message.Username,
				Nonce = message.Nonce,
				Realm = message.Realm,
				MessageIntegrity = new MessageIntegrity(),
			};

			byte[] actual2 = message2.GetBytes(password, true);

			Helpers.AreArrayEqual(bytes, actual2);
		}

		/// <summary>
		/// MS-TURN test
		/// </summary>
		[Test()]
		public void MsTurnMessageTest()
		{
			byte[] bytes = new byte[]
			{
				//0x00, 0x04, 0x23, 0x1E,
				//0xE6, 0x2D, 0x50, 0x18,
				//0x3F, 0x87, 0xF0, 0x9A,
				//0x00, 0x00, 0x02, 0x00,
				//0x00, 0xB1, 
							0x00, 0x03,
				0x00, 0x9D, 0x30, 0xB8,
				0xC9, 0xC7, 0xAF, 0xFC,
				0xF4, 0xA2, 0x4D, 0xDB,
				0x6E, 0x2A, 0x0A, 0xE0,
				0xEA, 0x5D, 0x00, 0x0F,
				0x00, 0x04, 0x72, 0xC6,
				0x4B, 0xC6, 0x80, 0x08,
				0x00, 0x04, 0x00, 0x00,
				0x00, 0x01, 0x00, 0x06,
				0x00, 0x34, 0x01, 0x00,
				0x00, 0x20, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x4C, 0x6F,
				0x67, 0x2E, 0x88, 0xC2,
				0xF8, 0xDE, 0xB8, 0x4E,
				0x72, 0x65, 0x5C, 0x43,
				0x31, 0x49, 0x07, 0x94,
				0x46, 0xC2, 0x19, 0x77,
				0x73, 0x92, 0xE0, 0x24,
				0x03, 0x08, 0x1D, 0x86,
				0x27, 0xA8, 0x50, 0x45,
				0x1D, 0xB5, 0x41, 0x8E,
				0xC6, 0xCA, 0x00, 0x14,
				0x00, 0x26, 0x62, 0x62,
				0x30, 0x30, 0x65, 0x65,
				0x30, 0x32, 0x2D, 0x31,
				0x62, 0x38, 0x38, 0x2D,
				0x34, 0x31, 0x39, 0x35,
				0x2D, 0x39, 0x38, 0x34,
				0x34, 0x2D, 0x39, 0x38,
				0x36, 0x39, 0x64, 0x37,
				0x38, 0x39, 0x30, 0x33,
				0x62, 0x61, 0x78, 0x78,
				0x00, 0x15, 0x00, 0x0F,
				0x6F, 0x66, 0x66, 0x69,
				0x63, 0x65, 0x73, 0x69,
				0x70, 0x2E, 0x6C, 0x6F,
				0x63, 0x61, 0x6C, 
				0x00, 0x08, 0x00, 0x14,	//     MESSAGE-INTEGRITY attribute header
				0x29,					//  }
				0x48, 0x38, 0xD7, 0x37,	//  }
				0x62, 0xB1, 0x26, 0x70,	//  }  HMAC-SHA1
				0x95, 0xA3, 0x13, 0xAF,	//  }
				0xA3, 0xBE, 0x78, 0x86,	//  }
				0xFE, 0x53, 0x08,		//  }
			};

			byte[] key1 = new byte[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, };
			byte[] key2 = new byte[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, };
			string nonce = "bb00ee02-1b88-4195-9844-9869d78903baxx";
			string realm = "officesip.local";
			string usernameBase64 = @"AQAAIAAAAAAAAAAATG9nLojC+N64TnJlXEMxSQeURsIZd3OS4CQDCB2GJ6hQRR21QY7Gyg==";
			string passwordBase64 = @"oUU0sl7OCLQNpLUYuI1cX7OAwXE=";

			TurnMessage message = TurnMessage.Parse(bytes, TurnMessageRfc.MsTurn);

			Assert.AreEqual(MessageType.AllocateRequest, message.MessageType);
			Assert.AreEqual(nonce, message.Nonce.Value);
			Assert.AreEqual(realm, message.Realm.Value);
			Assert.AreEqual(usernameBase64, Convert.ToBase64String(message.MsUsername.Value));
			Assert.IsTrue(message.IsValidMsUsername(key1));
			Assert.AreEqual(passwordBase64, Convert.ToBase64String(message.ComputeMsPasswordBytes(key2)));
			Assert.IsTrue(message.IsValidMessageIntegrity(key2), @"IsValidMessageIntegrity failed.");

			message.MessageIntegrity = new MessageIntegrity();
			Helpers.AreArrayEqual(bytes, message.GetBytes(key2));
		}

		/// <summary>
		/// MS-TURN test
		/// </summary>
		[Test()]
		public void MsTurnMessageTest2()
		{
			byte[] bytes = new byte[]
			{
				0x00, 0x03, 0x00, 0x9B,
				0x4A, 0x07, 0x32, 0x01,
				0x52, 0x11, 0xE9, 0x94,
				0xAE, 0x02, 0x4A, 0x13,
				0x8A, 0xA2, 0x0D, 0x26,
				0x00, 0x0F, 0x00, 0x04,
				0x72, 0xC6, 0x4B, 0xC6,
				0x80, 0x08, 0x00, 0x04,
				0x00, 0x00, 0x00, 0x01,
				0x00, 0x06, 0x00, 0x34,
				0x01, 0x00, 0x00, 0x20,
				0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00,
				0x4C, 0x6F, 0x67, 0x2E,
				0x88, 0xC2, 0xF8, 0xDE,
				0xB8, 0x4E, 0x72, 0x65,
				0x5C, 0x43, 0x31, 0x49,
				0x07, 0x94, 0x46, 0xC2,
				0x19, 0x77, 0x73, 0x92,
				0xE0, 0x24, 0x03, 0x08,
				0x1D, 0x86, 0x27, 0xA8,
				0x50, 0x45, 0x1D, 0xB5,
				0x41, 0x8E, 0xC6, 0xCA,
				0x00, 0x14, 0x00, 0x24,
				0x61, 0x34, 0x31, 0x66,
				0x37, 0x61, 0x63, 0x35,
				0x2D, 0x38, 0x32, 0x37,
				0x64, 0x2D, 0x34, 0x30,
				0x65, 0x37, 0x2D, 0x38,
				0x35, 0x31, 0x33, 0x2D,
				0x63, 0x35, 0x66, 0x36,
				0x39, 0x31, 0x65, 0x35,
				0x66, 0x61, 0x64, 0x34,
				0x00, 0x15, 0x00, 0x0F,
				0x6F, 0x66, 0x66, 0x69,
				0x63, 0x65, 0x73, 0x69,
				0x70, 0x2E, 0x6C, 0x6F,
				0x63, 0x61, 0x6C, 0x00,
				0x08, 0x00, 0x14, 0xE3,
				0xB3, 0x88, 0x94, 0x79,
				0x3B, 0x28, 0x3A, 0x34,
				0x67, 0xA4, 0x46, 0xAD,
				0xD5, 0x6C, 0xD0, 0xE6,
				0xA7, 0x50, 0x90,
			};

			byte[] key1 = new byte[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, };
			byte[] key2 = new byte[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, };
			string nonce = "a41f7ac5-827d-40e7-8513-c5f691e5fad4";
			string realm = "officesip.local";

			TurnMessage message = TurnMessage.Parse(bytes, TurnMessageRfc.MsTurn);

			Assert.AreEqual(MessageType.AllocateRequest, message.MessageType);
			Assert.AreEqual(nonce, message.Nonce.Value);
			Assert.AreEqual(realm, message.Realm.Value);
			Assert.IsTrue(message.IsValidMsUsername(key1));
			Assert.IsTrue(message.IsValidMessageIntegrity(key2), @"IsValidMessageIntegrity failed.");

			message.MessageIntegrity = new MessageIntegrity();
			Helpers.AreArrayEqual(bytes, message.GetBytes(key2));
		}


		/// <summary>
		/// MS-TURN test // message integrity send request
		/// </summary>
		[Test()]
		public void MsTurnMessageTest3()
		{
			byte[] bytes = new byte[]
			{
				0x00, 0x04, 0x01, 0x13,
				0xe0, 0x8d, 0x79, 0x8f,
				0xae, 0x56, 0xbf, 0x16,
				0x4f, 0x15, 0xdd, 0xe9,
				0x8c, 0x7e, 0x87, 0x7e,
				0x00, 0x0f, 0x00, 0x04,
				0x72, 0xc6, 0x4b, 0xc6,
				0x80, 0x08, 0x00, 0x04,
				0x00, 0x00, 0x00, 0x01,
				0x80, 0x50, 0x00, 0x18,
				0xf0, 0x99, 0x55, 0xbd,
				0x46, 0x61, 0x2f, 0xd5,
				0xd7, 0xa8, 0xee, 0x2d,
				0xae, 0x3b, 0xf8, 0x64,
				0x2f, 0x50, 0x39, 0x73,
				0x00, 0x00, 0x00, 0x5a,
				0x00, 0x06, 0x00, 0x34,
				0x01, 0x00, 0x00, 0x20,
				0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00,
				0x45, 0x2c, 0xca, 0xf7,
				0xc8, 0xa2, 0xe2, 0x36,
				0xf6, 0x18, 0xee, 0x4e,
				0x29, 0x24, 0xb7, 0xc3,
				0x3b, 0xf7, 0xc6, 0x1f,
				0x25, 0xa0, 0x90, 0xa5,
				0x24, 0xa3, 0xe3, 0x3d,
				0x66, 0x9f, 0xdf, 0x5e,
				0x6b, 0x89, 0x87, 0xf3,
				0x90, 0x7c, 0x3e, 0xe0,
				0x00, 0x11, 0x00, 0x08,
				0x00, 0x01, 0xc9, 0xcd,
				0xc0, 0xa8, 0x01, 0x0f,
				0x00, 0x13, 0x00, 0x87,
				0x80, 0xc9, 0x00, 0x01,
				0x0f, 0x9b, 0xea, 0x31,
				0x23, 0x50, 0x8e, 0x1d,
				0x2c, 0x5c, 0x2c, 0x64,
				0x86, 0x9c, 0x56, 0x25,
				0x9f, 0xb6, 0x34, 0x1c,
				0x7f, 0x6e, 0xa5, 0xe6,
				0x55, 0x19, 0xe9, 0x2a,
				0x2a, 0x95, 0x97, 0x45,
				0xe5, 0xe4, 0xa5, 0x89,
				0xbe, 0xf6, 0x3c, 0x21,
				0xbc, 0xcf, 0x5a, 0xef,
				0xa1, 0xc4, 0x65, 0x24,
				0x08, 0xd7, 0xda, 0xeb,
				0x44, 0x48, 0xb9, 0x15,
				0xc0, 0xac, 0x84, 0xcf,
				0xdd, 0xaa, 0x65, 0x8e,
				0x12, 0x35, 0x8c, 0xc7,
				0xcf, 0x93, 0x06, 0x85,
				0xd2, 0x7b, 0x8e, 0x06,
				0xd6, 0xfc, 0xcf, 0x57,
				0x79, 0x43, 0xd1, 0x66,
				0x36, 0x92, 0x66, 0xdf,
				0x38, 0x22, 0xcd, 0x65,
				0x2d, 0xc3, 0xa4, 0x74,
				0xdf, 0xa7, 0x91, 0x2d,
				0x93, 0x23, 0xea, 0x75,
				0x42, 0x1f, 0x14, 0xa9,
				0xe3, 0x56, 0xc3, 0xd8,
				0xc1, 0x18, 0x2d, 0x4a,
				0x80, 0x00, 0x00, 0x3c,
				0x01, 0xb1, 0xb2, 0xae,
				0x98, 0xd1, 0x5d, 0x9b,
				0x3f, 0xa9, 0xc4, 0x00,
				0x08, 0x00, 0x14, 0xdd,
				0x16, 0x9f, 0xb2, 0x75,
				0x39, 0x69, 0x92, 0xf2,
				0x2e, 0x8c, 0x6b, 0xaa,
				0x67, 0xcf, 0x16, 0x33,
				0xc8, 0xbe, 0x07,
			};

			byte[] key1 = new byte[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, };
			byte[] key2 = new byte[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, };

			TurnMessage message = TurnMessage.Parse(bytes, TurnMessageRfc.MsTurn);

			message.Realm = new Realm(TurnMessageRfc.MsTurn) { Value = "officesip.local", };

			Assert.AreEqual(MessageType.SendRequest, message.MessageType);
			Assert.IsTrue(message.IsValidMsUsername(key1));
			Assert.IsTrue(message.IsValidMessageIntegrity(key2), @"IsValidMessageIntegrity failed.");
		}

		/// <summary>
		/// MS-TURN test // message integrity send request
		/// </summary>
		[Test()]
		public void MsTurnMessageTest4()
		{
			byte[] bytes = new byte[]
			{
				0x00, 0x04, 0x01, 0x04,
				0x05, 0x05, 0x1D, 0x39,
				0xAA, 0x39, 0x58, 0x49,
				0x79, 0x0D, 0x59, 0x0B,
				0x24, 0x79, 0x0B, 0x4D,
				0x00, 0x0F, 0x00, 0x04,
				0x72, 0xC6, 0x4B, 0xC6,
				0x80, 0x08, 0x00, 0x04,
				0x00, 0x00, 0x00, 0x01,
				0x80, 0x50, 0x00, 0x18,
				0x06, 0x1C, 0xF9, 0x10,
				0xC4, 0x3A, 0x3B, 0x08,
				0x60, 0xD5, 0xA7, 0x00,
				0x04, 0x4B, 0x05, 0xA5,
				0x40, 0xF7, 0x73, 0x9E,
				0x00, 0x00, 0x00, 0x01,
				0x00, 0x06, 0x00, 0x34,
				0x01, 0x00, 0x00, 0x20,
				0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00,
				0x5E, 0xE3, 0x27, 0xE3,
				0xF4, 0xB5, 0xF8, 0xDE,
				0x63, 0x8D, 0x3D, 0x73,
				0x43, 0xF6, 0xD8, 0x2C,
				0x64, 0x56, 0xE2, 0x03,
				0xCD, 0xBC, 0xCA, 0x33,
				0xAB, 0x03, 0xEF, 0x2D,
				0xAB, 0x01, 0xD6, 0xC8,
				0x99, 0x9D, 0xE2, 0x4E,
				0x6C, 0x8E, 0xB6, 0xED,
				0x00, 0x11, 0x00, 0x08,
				0x00, 0x01, 0xE1, 0x9D,
				0xC0, 0xA8, 0x01, 0x0F,
				0x00, 0x13, 0x00, 0x78,
				0x00, 0x01, 0x00, 0x64,
				0x7F, 0x52, 0x04, 0x22,
				0x1C, 0x5E, 0x73, 0x53,
				0x4A, 0xD7, 0x49, 0x58,
				0xEA, 0x22, 0x1F, 0xF0,
				0x00, 0x06, 0x00, 0x48,
				0xAD, 0x2B, 0x14, 0x6A,
				0x3F, 0xF0, 0xCF, 0x0F,
				0x91, 0x6E, 0xDE, 0x73,
				0xD7, 0xBA, 0xAA, 0xEA,
				0xBF, 0x6D, 0x9B, 0xEB,
				0x9A, 0x6D, 0x26, 0x21,
				0xED, 0x3E, 0x97, 0x4B,
				0xDB, 0x95, 0x61, 0xCA,
				0x3A, 0x32, 0x3A, 0xBA,
				0x8F, 0x1C, 0x51, 0xAC,
				0x35, 0xCF, 0x21, 0x53,
				0xED, 0x42, 0x91, 0xC9,
				0x63, 0x4D, 0x76, 0x1C,
				0x61, 0x6E, 0x95, 0x3F,
				0x45, 0xC1, 0x11, 0x50,
				0x8A, 0xAD, 0x92, 0x8E,
				0x34, 0xF9, 0xA2, 0x3A,
				0x32, 0x00, 0x00, 0x00,
				0x00, 0x08, 0x00, 0x14,
				0xFD, 0xA2, 0x22, 0x0F,
				0x10, 0x6B, 0x95, 0xFF,
				0xF1, 0x51, 0x4D, 0x7B,
				0x63, 0xF9, 0x17, 0x0D,
				0x91, 0x99, 0x04, 0x25,
				
				0x00, 0x08, 0x00, 0x14,
				0xEB, 0xB5, 0x0C, 0x16,
				0xFF, 0x81, 0x6F, 0xEC,
				0x8F, 0x1A, 0xFF, 0x41,
				0xC9, 0x80, 0x37, 0x51,
				0x36, 0xDE, 0xBF, 0x3B,
			//	0x00, 0x00, 0x00, 0x00,
			//	0x00, 0x00, 0x00, 0x00,
			//	0x00, 0x00, 0x00, 0x00,
			//	0x00, 0x00, 0x00, 0x00,
			//	0x00, 0x00, 0x00, 0x00,
			//	0x00, 0x00, 0x00, 0x00,
			};

			byte[] key1 = new byte[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, };
			byte[] key2 = new byte[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, };

			TurnMessage message = TurnMessage.Parse(bytes, TurnMessageRfc.MsTurn);

			message.Realm = new Realm(TurnMessageRfc.MsTurn) { Value = "officesip.local", };

			Assert.AreEqual(MessageType.SendRequest, message.MessageType);
			Assert.IsTrue(message.IsValidMsUsername(key1));
			Assert.IsTrue(message.IsValidMessageIntegrity(key2), @"IsValidMessageIntegrity failed.");
		}

		/// <summary>
		/// MS-TURN test // test buffer + startIndex
		/// </summary>
		[Test()]
		public void MsTurnMessageTest5()
		{
			byte[] bytes = new byte[]
			{
				0x00, 0x03, 0x00, 0x9B,
				0x4A, 0x07, 0x32, 0x01,
				0x52, 0x11, 0xE9, 0x94,
				0xAE, 0x02, 0x4A, 0x13,
				0x8A, 0xA2, 0x0D, 0x26,
				0x00, 0x0F, 0x00, 0x04,
				0x72, 0xC6, 0x4B, 0xC6,
				0x80, 0x08, 0x00, 0x04,
				0x00, 0x00, 0x00, 0x01,
				0x00, 0x06, 0x00, 0x34,
				0x01, 0x00, 0x00, 0x20,
				0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00,
				0x4C, 0x6F, 0x67, 0x2E,
				0x88, 0xC2, 0xF8, 0xDE,
				0xB8, 0x4E, 0x72, 0x65,
				0x5C, 0x43, 0x31, 0x49,
				0x07, 0x94, 0x46, 0xC2,
				0x19, 0x77, 0x73, 0x92,
				0xE0, 0x24, 0x03, 0x08,
				0x1D, 0x86, 0x27, 0xA8,
				0x50, 0x45, 0x1D, 0xB5,
				0x41, 0x8E, 0xC6, 0xCA,
				0x00, 0x14, 0x00, 0x24,
				0x61, 0x34, 0x31, 0x66,
				0x37, 0x61, 0x63, 0x35,
				0x2D, 0x38, 0x32, 0x37,
				0x64, 0x2D, 0x34, 0x30,
				0x65, 0x37, 0x2D, 0x38,
				0x35, 0x31, 0x33, 0x2D,
				0x63, 0x35, 0x66, 0x36,
				0x39, 0x31, 0x65, 0x35,
				0x66, 0x61, 0x64, 0x34,
				0x00, 0x15, 0x00, 0x0F,
				0x6F, 0x66, 0x66, 0x69,
				0x63, 0x65, 0x73, 0x69,
				0x70, 0x2E, 0x6C, 0x6F,
				0x63, 0x61, 0x6C, 0x00,
				0x08, 0x00, 0x14, 0xE3,
				0xB3, 0x88, 0x94, 0x79,
				0x3B, 0x28, 0x3A, 0x34,
				0x67, 0xA4, 0x46, 0xAD,
				0xD5, 0x6C, 0xD0, 0xE6,
				0xA7, 0x50, 0x90,
			};

			byte[] key2 = new byte[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, };

			TurnMessage message = TurnMessage.Parse(bytes, TurnMessageRfc.MsTurn);
			message.MessageIntegrity = new MessageIntegrity();

			message.ComputeMessageLength();

			int offset = 25;
			int length64 = offset + message.TotalMessageLength;
			if (length64 % 64 != 0)
				length64 += 64 - length64 % 64;
			byte[] bytes2 = new byte[length64];

			message.GetBytes(bytes2, offset, key2);

			Helpers.AreArrayEqual(bytes, 0, bytes2, offset);
		}


		/// <summary>
		/// IsTurnMessage test
		/// </summary>
		[Test()]
		public void IsTurnMessageTest()
		{
			byte[] bytes1 = new byte[]
			{
				0x00, 0x04, 0x01, 0x04,
				0x05, 0x05, 0x1D, 0x39,
				0xAA, 0x39, 0x58, 0x49,
				0x79, 0x0D, 0x59, 0x0B,
				0x24, 0x79, 0x0B, 0x4D,
				0x00, 0x0F, 0x00, 0x04,
				0x72, 0xC6, 0x4B, 0xC6,
				0x80, 0x08, 0x00, 0x04,
				0x00, 0x00, 0x00, 0x01,
			};

			byte[] bytes2 = new byte[]
			{
				0x00, 0x04, 0x01, 0x04,
				0x05, 0x05, 0x1D, 0x39,
				0xAA, 0x39, 0x58, 0x49,
				0x79, 0x0D, 0x59, 0x0B,
				0x24, 0x79, 0x0B, 0x4D,
				0x00, 0xaa, 0x00, 0x04,
				0x72, 0xC6, 0x4B, 0xC6,
				0x80, 0x08, 0x00, 0x04,
				0x00, 0x00, 0x00, 0x01,
			};

			byte[] bytes3 = new byte[]
			{
				0x00, 0x04, 0x01, 0x04,
				0x05, 0x05, 0x1D, 0x39,
				0xAA, 0x39, 0x58, 0x49,
				0x79, 0x0D, 0x59, 0x0B,
				0x24, 0x79, 0x0B, 0x4D,
				0x00, 0x0F, 0x00, 0x04,
				0x72, 0xC6, 0xaa, 0xC6,
				0x80, 0x08, 0x00, 0x04,
				0x00, 0x00, 0x00, 0x01,
			};

			byte[] bytes4 = new byte[]
			{
				0x00, 0x04, 0x01, 0x04,
				0x05, 0x05, 0x1D, 0x39,
				0xAA, 0x39, 0x58, 0x49,
				0x79, 0x0D, 0x59, 0x0B,
				0x24, 0x79, 0x0B, 0x4D,
				0x00, 0x0F, 0x00, 0xaa,
				0x72, 0xC6, 0x4B, 0xC6,
				0x80, 0x08, 0x00, 0x04,
				0x00, 0x00, 0x00, 0x01,
			};

			Assert.IsTrue(TurnMessage.IsTurnMessage(bytes1, 0, bytes1.Length));
			Assert.IsTrue(TurnMessage.IsTurnMessage(bytes1, 0, 28));
			Assert.IsFalse(TurnMessage.IsTurnMessage(bytes1, 0, 27));
			Assert.IsFalse(TurnMessage.IsTurnMessage(bytes2, 0, bytes2.Length));
			Assert.IsFalse(TurnMessage.IsTurnMessage(bytes3, 0, bytes3.Length));
			Assert.IsFalse(TurnMessage.IsTurnMessage(bytes4, 0, bytes4.Length));
		}

		/// <summary>
		/// MS-TURN test // data indication
		/// </summary>
		[Test()]
		public void MsTurnMessageTest6()
		{
			byte[] expected = new byte[]
			{
				0x01, 0x15, 0x00, 0xA9,
				0x1B, 0xE1, 0x64, 0x3C,
				0x91, 0x14, 0x00, 0x00,
				0x1B, 0xE1, 0x64, 0x3C,
				0x91, 0x14, 0x00, 0x00,
				0x00, 0x0F, 0x00, 0x04,
				0x72, 0xC6, 0x4B, 0xC6,
				0x00, 0x12, 0x00, 0x08,
				0x00, 0x01, 0x61, 0x4F,
				0xD5, 0x1B, 0x5D, 0x66,
				0x00, 0x13, 0x00, 0x91,
				0x00, 0x8F, 0x80, 0xC8,
				0x00, 0x09, 0x36, 0x15,
				0xDA, 0x97, 0x70, 0x3F,
				0x62, 0xFD, 0x22, 0x6C,
				0x49, 0x35, 0x03, 0xAA,
				0x99, 0xC4, 0x96, 0x3D,
				0x05, 0xFE, 0x10, 0xE8,
				0xFF, 0xEC, 0x9D, 0x6F,
				0xA2, 0x26, 0x44, 0x7C,
				0x40, 0xE5, 0x7C, 0xB0,
				0xAB, 0x2A, 0xA4, 0x66,
				0x1F, 0x5E, 0x74, 0x25,
				0x56, 0x3A, 0x0D, 0x64,
				0x8D, 0xBD, 0x8D, 0xFB,
				0xF4, 0x81, 0xA3, 0xED,
				0x60, 0x35, 0x2B, 0x01,
				0x7E, 0xC4, 0xF8, 0x6D,
				0xF0, 0x26, 0xBD, 0xFF,
				0xF3, 0x31, 0xA7, 0xA7,
				0xDC, 0xAF, 0x89, 0x9C,
				0xFA, 0xC1, 0xC7, 0x3E,
				0xC0, 0x65, 0x53, 0x9C,
				0x90, 0xDD, 0xAF, 0xCC,
				0x02, 0x2E, 0xF0, 0xF3,
				0xB9, 0xAA, 0x5D, 0xB6,
				0x07, 0xB5, 0x17, 0x2A,
				0xDE, 0xF0, 0x23, 0x52,
				0x01, 0x7F, 0xD3, 0xE6,
				0x16, 0xB1, 0xF2, 0x90,
				0x16, 0x5A, 0x79, 0xD6,
				0xE9, 0xC9, 0xB8, 0x5F,
				0x53, 0xE0, 0x25, 0x63,
				0x5B, 0x09, 0x80, 0x00,
				0x00, 0x05, 0x01, 0x85,
				0xBA, 0x35, 0xA0, 0xC8,
				0x79, 0xF7, 0xED, 0x47,
				0x91, 
			};

			TurnMessage message = new TurnMessage()
			{
				IsAttributePaddingDisabled = true,
				MessageType = MessageType.DataIndication,
				TransactionId = new TransactionId(expected, 4),

				MagicCookie = new MagicCookie(),

				RemoteAddress = new RemoteAddress()
				{
					IpEndPoint = new System.Net.IPEndPoint(System.Net.IPAddress.Parse("213.27.93.102"), 24911),
				},

				Data = new Data()
				{
					Value = new byte[]
					{
						0x00, 0x8F, 0x80, 0xC8,
						0x00, 0x09, 0x36, 0x15,
						0xDA, 0x97, 0x70, 0x3F,
						0x62, 0xFD, 0x22, 0x6C,
						0x49, 0x35, 0x03, 0xAA,
						0x99, 0xC4, 0x96, 0x3D,
						0x05, 0xFE, 0x10, 0xE8,
						0xFF, 0xEC, 0x9D, 0x6F,
						0xA2, 0x26, 0x44, 0x7C,
						0x40, 0xE5, 0x7C, 0xB0,
						0xAB, 0x2A, 0xA4, 0x66,
						0x1F, 0x5E, 0x74, 0x25,
						0x56, 0x3A, 0x0D, 0x64,
						0x8D, 0xBD, 0x8D, 0xFB,
						0xF4, 0x81, 0xA3, 0xED,
						0x60, 0x35, 0x2B, 0x01,
						0x7E, 0xC4, 0xF8, 0x6D,
						0xF0, 0x26, 0xBD, 0xFF,
						0xF3, 0x31, 0xA7, 0xA7,
						0xDC, 0xAF, 0x89, 0x9C,
						0xFA, 0xC1, 0xC7, 0x3E,
						0xC0, 0x65, 0x53, 0x9C,
						0x90, 0xDD, 0xAF, 0xCC,
						0x02, 0x2E, 0xF0, 0xF3,
						0xB9, 0xAA, 0x5D, 0xB6,
						0x07, 0xB5, 0x17, 0x2A,
						0xDE, 0xF0, 0x23, 0x52,
						0x01, 0x7F, 0xD3, 0xE6,
						0x16, 0xB1, 0xF2, 0x90,
						0x16, 0x5A, 0x79, 0xD6,
						0xE9, 0xC9, 0xB8, 0x5F,
						0x53, 0xE0, 0x25, 0x63,
						0x5B, 0x09, 0x80, 0x00,
						0x00, 0x05, 0x01, 0x85,
						0xBA, 0x35, 0xA0, 0xC8,
						0x79, 0xF7, 0xED, 0x47,
						0x91, 
					}
				},
			};

			byte[] bytes = message.GetBytes(null);

			Helpers.AreArrayEqual(expected, bytes);
		}
	}
}
